<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CKEditor 5 – classic editor build – development sample</title>
	<style>
		body {
			max-width: 800px;
			margin: 20px auto;
		}
/* 		.ck.ck-editor {
		    max-width: 100px;
		} */
		.ck-editor__editable_inline {
		    height: 400px;
		}

		a[target]::after {
		    content: "target=\"" attr(target) "\"";
		    font-size: 0.6em;
		    position: relative;
		    left: 0em;
		    top: -1em;
		    background: #00ffa6;
		    color: #000;
		    padding: 1px 3px;
		    border-radius: 10px;
		}
	</style>
</head>
<body>

<h1>CKEditor 5 – classic editor build – development sample</h1>

<textarea id="editor">
	<h2>Sample</h2>

	<p>This is an instance of the <a href="https://ckeditor.com/docs/ckeditor5/latest/builds/guides/overview.html#classic-editor">classic editor build</a>.</p>

	<figure class="image">
		<img src="../tests/manual/sample.jpg" alt="Autumn fields" />
	</figure>

	<p>You can use this sample to validate whether your <a href="https://ckeditor.com/docs/ckeditor5/latest/builds/guides/development/custom-builds.html">custom build</a> works fine.</p>
</textarea>

<button onclick="getData()">getData</button>
<button onclick="insertLink()">insertLink</button>

<script src="../build/ckeditor.js"></script>
<script>
	// full
	// $toolbar .= "'-','Templates'],
	// ['PasteText'],
	// ['Find','Replace'],
	// ['Maximize'],
	// ['Anchor']
	const editors = {};

	function AllowLinkTarget( editor ) {
	    // Allow the "linkTarget" attribute in the editor model.
	    editor.model.schema.extend( '$text', { allowAttributes: 'linkTarget' } );

	    // Tell the editor that the model "linkTarget" attribute converts into <a target="..."></a>
	    editor.conversion.for( 'downcast' ).attributeToElement( {
	        model: 'linkTarget',
	        view: ( attributeValue, writer ) => {
	            const linkElement = writer.createAttributeElement( 'a', { target: attributeValue }, { priority: 5 } );
	            writer.setCustomProperty( 'link', true, linkElement );

	            return linkElement;
	        },
	        converterPriority: 'low'
	    } );

	    // Tell the editor that <a target="..."></a> converts into the "linkTarget" attribute in the model.
	    editor.conversion.for( 'upcast' ).attributeToAttribute( {
	        view: {
	            name: 'a',
	            key: 'target'
	        },
	        model: 'linkTarget',
	        converterPriority: 'low'
	    } );
	}

	ClassicEditor.create( document.querySelector( '#editor' ),{
		extraPlugins: [ AllowLinkTarget ],
		wordCount: {
			onUpdate: stats => {
				// Prints the current content statistics.
				console.log( `Characters: ${ stats.characters }\nWords: ${ stats.words }` );
			}
		},
		image: {
			upload: {
				types: [ 'png', 'jpeg', 'bmp', 'gif' ]
			}
		},
		// ckfinder: {
		// 	uploadUrl: 'https://example.com/ckfinder/core/connector/php/connector.php?command=QuickUpload&type=Images&responseType=json',
		// 	options: {
		// 		resourceType: 'Images'
		// 	}
		// },
		// toolbarView:{
		// 	shouldGroupWhenFull: false,
		// },
		toolbar: [
			'insertImage',
			'heading',
			'|',
			'bold',
			'link',
			'|',
			'removeFormat',
			'|',
			'alignment',
			'horizontalLine',
			'indent',
			'outdent',
			'|',
			'imageUpload',
			'mediaEmbed',
			'|',
			'fontSize',
			'fontFamily',
			'fontColor',
			'highLight',
			'|',
			'bulletedList',
			'numberedList',
			'|',
			'insertTable',
			'italic',
			'underline',
			'strikeThrough',
			'subScript',
			'superScript',
			'undo',
			'redo'
		]
	} )
	.then( editor => {
		editors[ 'content' ] = editor;

		editor.model.change( writer => {
		    writer.insertText( 'foo', editor.model.document.selection.getFirstPosition() );
		} );

		// Apply bold to the entire selection.
		editor.model.change( writer => {
		    for ( const range of editor.model.document.selection.getRanges() ) {
		        writer.setAttribute( 'bold', true, range );
		    }
		} );

		const clipboardPlugin = editor.plugins.get( 'Clipboard' );

		editor.editing.view.document.on( 'paste', ( evt, data ) => {
			console.log('paste');
			const dataTransfer = data.dataTransfer;
			var content = dataTransfer.getData( 'text/html' );
			content = content.replace(/data\-src/g,"src");
			// dataTransfer.setData('text/html',"helloBack");
			content = clipboardPlugin._htmlDataProcessor.toView( content );
			clipboardPlugin.fire( 'inputTransformation', { content, dataTransfer } );

			evt.stop();
		});
		editor.editing.view.document.on( 'clipboardInput', ( evt, data ) => {
			console.log('clipboardInput');
// 		    const dataTransfer = data.dataTransfer;
// 		    const rtfContent = dataTransfer.getData( );
// console.log(rtfContent);
		//     // If no RTF was pasted, abort and let the clipboard feature handle the input.
		//     if ( !rtfContent ) {
		//         return;
		//     }

		//     // Convert an RTF raw string to a view document fragment.
		//     const viewContent = convertRtfStringToView( rtfContent );

		//     // Just like the clipboard feature, trigger the inputTransformation event
		//     // to allow further processing of the content.
		//     this.fire( 'inputTransformation', { content: viewContent, dataTransfer } );

		//     editor.editing.view.scrollToTheSelection();
		//     evt.stop();
		} );
		editor.ui.focusTracker.on( 'change:isFocused', ( evt, name, value ) => {
		    console.log( 'isFocused = ', value );
		} );
		console.log(editor.config.get('toolbar.collapsed'));
		editor.config.set('toolbar.toolbarView.shouldGroupWhenFull',false);
	} )
	.catch( err => {
		console.error( err.stack );
	} );
	function getData(){
		console.log(editors['content'].getData());
	}
	function insertLink(){
		var editor = editors[ 'content' ]
		editor.model.change( writer => {
			var linkText = 'this is a link!';
			var linkUrl = 'http://www.baidu.com/';
		    const insertPosition = editor.model.document.selection.getFirstPosition();
		    writer.insertText( linkText, { linkHref: linkUrl }, insertPosition );
		} );
	}
</script>

</body>
</html>
